#!/bin/python3
import sys
import readline
import atexit
import os
import math

HISTORY_FILE = os.path.expanduser('~/.pymath_history')
HISTORY_SIZE = 1000


equation = " ".join(sys.argv[1:])
Any = type
parser = type


operands = ["^", "*", "/", "+", "-", "%"] # "^*/+-%"

class Operand:
    def __init__(self):
        pass

    def solve(self):
        pass

class add(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a + b

    
    def __repr__(self):
        return f"({self.a} + {self.b})"

class sub(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a - b
    
    def __repr__(self):
        return f"({self.a} - {self.b})"

class mul(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a * b
    
    def __repr__(self):
        return f"({self.a} * {self.b})"

class div(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a / b

    def __repr__(self):
        return f"({self.a} / {self.b})"

class pow(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a ** b
    
    def __repr__(self):
        return f"({self.a} ^ {self.b})"

class mod(Operand):
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def solve(self):
        a = self.a
        b = self.b
        if isinstance(a, Operand):
            a = a.solve()
        if isinstance(b, Operand):
            b = b.solve()
        return a % b
    
    def __repr__(self):
        return f"({self.a} % {self.b})"


def eat_str(what : str, text : str):
    if text.startswith(what):
        return True, text[len(what):]
    return None, f"cant eat {what}"

def parse_parens(inner : callable):
    def parens_p(text):
        ret, right = eat_str("(", text)
        if ret:
            inner_obj, right = inner(right)
            if inner_obj is not None:
                ret, right = eat_str(")", right)
                if ret:
                    return inner_obj, right
            else:
                return None, right
        return None, text
    return parens_p

def try_parse_multiple(text, *parsers) -> tuple[Any | None, str]:
    fails = []
    for parser in parsers:
        ret, right = parser(text)
        if ret is not None:
            return ret, right
        else:
            fails.append(right)
    return None, f"no parser succeded: {fails}"

def case_parse(text, cases : list[tuple[callable, parser]]):
    for case_check, case_parser in cases:
        if case_check(text):
            return case_parser(text)
    return None, "no cases matched"

def parse_number(text : str):
    imag = False
    neg = False
    length = 0
    if len(text) == 0:
        return None, "recieved empty string"
    if text.startswith("-"):
        neg = True
        text = text[1:]
    if text.lower().startswith("pi"):
        return math.pi * (-1 if neg else 1), text[2:]
    elif text.lower().startswith("e"):
        return math.e * (-1 if neg else 1), text[1:]
    elif text.lower().startswith("tau"):
        return math.tau * (-1 if neg else 1), text[2:]
    elif text.lower().startswith("phi"):
        return (1+math.sqrt(5))/2 * (-1 if neg else 1), text[3:]
    elif text.lower().startswith("j"):
        return 1j * (-1 if neg else 1), text[1:]
    else:
        keys = [key for key in equations if text.startswith(key)]
        if keys:
            lengths = list(map(len, keys))
            index = lengths.index(max(lengths))
            key = keys[index] # take the longest key
            value = equations[key]
            return value, text[len(key):]
        else:
            number = ""
            for c in text:
                if c in "0123456789._":
                    number += c
                    length += 1
                elif c == "j":
                    imag = True
                    length += 1
                    break
                else:
                    break
            if number:
                try:
                    value = int(number)
                except:
                    value = float(number)
                number = value * (1j if imag else 1) * (-1 if neg else 1)
                return number, text[length:]
    return None, f"no pattern matches for number: {text.split(" ")[0]}"

def parse_operation(text):
    if text:
        if text[0] in operands:
            return text[0], text[1:]
    return None, f"{text[0]} is not an operand" if len(text) > 0 else "recieved empty string"

def merge_operators(args : list, operators : list):
    assert len(args) == len(operators) + 1
    while True:
        place = -1
        constructor_class = None
        for operand, constructor in zip("^/*+-%", [pow, div, mul, add, sub, mod]):
            try:
                place = operators.index(operand)
                constructor_class = constructor
                break
            except:
                pass
        if place != -1:
            a, b = args[place], args.pop(place+1)
            c = constructor_class(a, b)
            args.pop(place)
            args.insert(place, c)
            operators.pop(place)
        else:
            break
    return args[0]

def parse_atom(text):
    return case_parse(text, [(lambda x : (x.strip().startswith("(")), parse_parens(parse_arithmetic)), (lambda x : (True), parse_number)])
    #return try_parse_multiple(text, parse_number, parse_parens(parse_arithmetic))

def parse_series(text):
    a, right = parse_atom(text.strip())
    if a is None:
        return None, f"can't parse atom for series: {text}"
    args = [a]
    operators = []
    while True:
        op, right_ = parse_operation(right.strip())
        if op is None:
            break
        arg, right_ = parse_atom(right_.strip())
        if arg is None:
            break
        operators.append(op)
        args.append(arg)
        right = right_
    return merge_operators(args, operators), right

def is_symbol(symbol):
    if symbol[0] in "1234567890 ":
        return False
    if any([c in symbol for c in " ()[]()[]/*+-."]):
        return False
    return True


def parse_arithmetic(text):
    return try_parse_multiple(text, parse_series, parse_atom)


def parse_equation(text : str):
    parts = text.split("=")
    if len(parts) == 2:
        symbol, value = parts
        symbol = symbol.strip()
        if not is_symbol(symbol):
            return None, f"symbol is invalid: {symbol}"
        value, right = parse_arithmetic(value.strip())
        if symbol is not None and value is not None:
            return (symbol, value), right
    return None, "too many parts"


if os.path.exists(HISTORY_FILE):
    readline.read_history_file(HISTORY_FILE)
readline.set_history_length(HISTORY_SIZE)
atexit.register(readline.write_history_file, HISTORY_FILE)

# Optional: Set a different completion/editing mode if desired (e.g., 'vi')
# readline.set_editing_mode('emacs') # Default, or 'vi'


def solve_arithmetic(math : int | float | complex | Operand):
    value = None
    if isinstance(math, Operand):
        value = math.solve()
    elif isinstance(math, (int, float, complex)):
        value = math
    if value is not None:
        if isinstance(value, complex):
            if abs(value.imag) < abs(value.real)*1e-7:
                value = value.real
        if isinstance(value, float):
            if abs(value - round(value)) < 1e-10 and abs(value) > 0.5:
                value = round(value)
    return value

equations = {}


if equation:
    eq, right = parse_arithmetic(equation)
    value = solve_arithmetic(eq)
    if value:
        print(f"{value}")
        if right:
            print(f"unparsed: {right}")
    else:
        print(f">error: {right}")
    exit()


try:
    while True:
        equation = input("Â» ")
        if "=" in equation:
            eq, right = parse_equation(equation)
            if eq is None:
                print(f">error: {right}")
                continue
            symbol, arithmetic = eq
            value = solve_arithmetic(arithmetic)
            if value is not None:
                equations[symbol] = value
                print(f"{symbol} = {value}")
                if right:
                    print(f"unparsed: {right}")
            else:
                print(f">error: {right}")
        else:
            eq, right = parse_arithmetic(equation)
            value = solve_arithmetic(eq)
            if value is not None:
                print(f"= {value}")
                if right:
                    print(f"unparsed: {right}")
            else:
                print(f">error: {right}")
except KeyboardInterrupt:
    print("^C")
    pass
except EOFError: # Ctrl+D
    print()


